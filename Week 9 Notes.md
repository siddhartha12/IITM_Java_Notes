# L9.1 - Optional Types
dealing with empty streams
* Largest and smallest values seen
	* max() and min()
	* requires a comparison function
	* what happens if the stream is empty
* max() of empty stream is undefined
	* return value could be double or null
* `Optional <T>` object
	* wrapper
	* may contain an object of type T
		* value is present
	* or no object
* Use `orElse()` to pass a default value - input is a value
* Use `orElseGet()` to call a function to generate replacement for a missing value
* use `orElsethrow()` to generate an exception when a missing value is encountered

Ignoring missing values
* ifPresent() to test if a value is present, and process it
	* missing value is ignored
* For instance, add maxrand to a collection results, if it is present
* can also use `ifPresentOrElse()` - specify an alternative action

Creating an optional value
* Creating an optional value
	* Optional.of(v) creates value v
	* Optional.empty creates empty optional
* Use ofNullable() to transform null automatically into an empty optional
	* useful when working with functions that return object of type T or null, rather than `Optional<T>
* Can produce an output Optional value from an input Optional
* map applied function to value, if present
	* if input is empty, so is output
* Supply an alternative for a missing value
	* if value is present, it is passed as is 
	* If value is empty, value generated by or() is passed

Composing optional values of different types
* Suppose that
	* f() returns `Optional<T>
	* Class T defines g(), returning `Optional<U>
* Cannot compose `s.f().g()
	* s.f() has type ``Optional<T>` not T
* Instead use flatmap
	* `s.f().flatmap(T::g)
	* if s.f() is present apply g
	* Otherwise return empty `Optional<U>
* For example, pass output of earlier safe inverse() to save squareRoot()

Turning an optional into a stream
* suppose lookup(u) returns a User if u is a valid username
* want to convert a stream of userids into a stream of users
	* `Stream<User> users = ids.map(Users::lookup).flatMap(Optional::stream);

# L9.2 - Collecting Results from Streams
* Convert collections into sequence of values - streams
* Process a stream as a collection?
* Stream defines a standard iterator, use to loop through values in a stream
* Alternatively use forEach with a suitable function
  `mystream.forEach(System.out::println);
* can convert a stream into an array using toArray
	* creates an array of Object by default
* Pass array constructor to get a more specific array type
  `string[] result = mystream.toarray(string[]::new);`

Storing a stream as a colleciton
* What if we want to convert the stream back into a collection?
* Use collect()
	* Pass appropriate factory method from Collectors
	* static method that directly calls a constructor
* Create a list from stream
  `List<String> result = mystream.collect(Collectors.toList());
* can do for
	* list - toList
	* set - toSet
	* Treeset - `collectors.tocollection(treeset::new)

Stream summaries
* how to reduce a stream to a single result value - count(), max()
* Collectors has methods to aggregate summaries in a single object
	* summarizingInt works for a stream of integers
	* pass function to convert given stream to number 
	* returns IntSummarystatistics that stores count, max, min, sum, average
	  `IntSummaryStatistics summary = mystream.collect(Collectors.summarizingInt(String::length));`
	* methods to access relevant statistics 

Convert stream to a map
* Convert a stream of person to a map
	* for person p, p.getID() is key and p.getName() is value
* To store entire object as value, use Function.identity()
* What happens if we use name for key and id for value
	* likely to have duplicate keys - IllegalStateException
* Provide a function to fix such problems

Grouping and partitioning values
* Instead of discarding values with duplicate keys, group them
	* eg group name with corresponding id numbers
	* `people.collect(Collectors.groupingBy(Person::getName)`
* May want to partition the stream using a predicate
* Partition names into those that start with A and the rest
	* Key values of resulting map are true and false
	* `Map<Boolean, List<Person>> aAndOtherPersons = people.collect(Collectors.partitioningBy(p->p.getName().substr(0,1).equals("A"))); List<Person> startingLetterA = aAndOtherPersons.get(true)`

# L9.3 - Input Output Streams
* Input: read a sequence of bytes from some source
* Output: Write a sequence of bytes to some source
* Java refers to these as input and output streams
	* not the same as stream objects in class Stream
* Inut and output values could be of different types
	* ultimately input and output are raw uninterpreted bytes aof data
	* interpret as text or as binry data
* Use a pipeline of input/output transformers
	* Read raw bytes form a file, pass to stream that reads text
	* Generate binary data, pass to a stream that writes raw bytes to a file

reading and writing raw bytes
* Classes InputStream and OutputStream
* Read one or more bytes - abstract methods are implemented by subclasses of InputStream
* Check availability before reading
* write bytes to output
* Close a stream when done - release resources
* Flush an output stream - output is buffered - releasing the output resoruce

Connecting a stream to an external source
* Input and output streams ultimately connect to external resources
	* A file, an internet connection, memory
	* We limit ourselves to files
* Create an input stream attached to a file
  `var in = new FileInputStream("Input.class")`
* Create an output stream attached to a file
  `var out = new FileOutputStream("Input.class")`
* Overwrite or append
	* pass a boolean second argument to the constructor
		* false - Overwrite
		* true - append

Reading and writing text
* Recall Scanner class
	* can apply to any input stream
	  `var scin = new Scanner(new FileInputStream("Input.txt"));`
* Many read methods
	* scin.nextline()
	* next() - one word
	* nextInt() - next int
	* hasNext() - any more words
* To write text, use PrintWriter class
	* apply to any output stream
	* `pout var = new PrintWriter( new fileoutstream ); pout.println(string)


reading and writing binary
* use DataInputStream class
	* can apply to any input stream
* Read methods
	* readint
	* readshort
	* readlong
	* readfloat
	* readdouble
	* readchar
	* readutf
	* readBoolean, etc
* To write binary use DataOutputStream class
	* write int etc. like above

Other features
* Buffering an input stream
	* reads block of data
	* more efficient
* Speculative read
	* exmaine the first element
	* return to stream if necessary
Miscellaneous chaining together of streams


# L9.4 - Serialization
* To write object, java has another output - ObjectOutputStream
* use writeObject() to write out an object
* To read back objects in same order they were written, using readObject()
* Class has to allow serializatin - implement marker interface Serializable

How serialization works:
* ObjectOutputStream examines all the fields and saves thier contents
* ObjectInputStream "reconstructs" the object, effectively calls a constructor
* what happens when many objects share the same object as an instance variable
	* two manages have the same secretary
	* how to avoid duplication
* Each object is assigned a serial number - Hence serialization
	* When first encountered, save the data to output stream
	* If saved previously, record serial number
	* Reverse the process when reading

customizing serialization
* Some objects should not be serialized - values of file handles
* mark such fields as transient
* can override writeObject()
	* defaultWriteObject() writes out the object with all non-transient fields
	* then explicitly write relevant details of transient details
* and readObject()
	* defaultReadObject() reconstructs object with all non-transient fields
	* then explicitly reconstructs transient fields

Example
```
private void writeObject(ObjectOutputStream out) throws IOException {
	out.defaultWriteObject();
	out.writeDouble(point.getX());
	out.writeDouble(point.getY());
}

private void readObject(ObjectInputStream in) throws IOException {
	in.defaultReadObject();
	double x = in.readDouble();
	double y = in.readDouble();
	point = new Point2d.Double(x, y);
}
```