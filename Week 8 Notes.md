# L8.1 - Cloning
* Normal assignment creates two references of the same object
	* Updates via either name update the object
* if we want two separate but identical objects ?
* Object defines a method clone()
* e1.clone() returns a bitwise copy of e1
	* Object does not have access to private instance variable
	* cannot build up a fresh copy of e1
* Why not good?

Issues with bitwise copy
* Say a class is complex with another class object inside it
* in the primary class, it simply has a pointer to the sub-object
* that gets copied, so from now on, any change in one super object subobject will also end up changing in the other
* Bitwise copy is a shallow copy

Deep Copy
* Recursively clones nested objects
* override the shallow clone() from object
* object.clone() returns an object, 
	* cast super.clone()
* Employee.Clone() returns an Employee

Restrictions
* To allow clone() to be used, a class has to implement Cloneable interface 

# L8.2 - Type Inference
it means, derive the type from expressions

type inference
* assume program is type-safe, derive most general types compatible with code
	* use information frmo cconstants to determine type
	* Propogate type informatino bsed on inferd types
* typing judgements should ideally be made at compile time, not at runtime
	* statis analysis of code
* Balance flexibility with algorithmic tractability
	* algorithmically not  possible, have to make it constrained

in java
* allows limited type inference
	* only for local variables
	* not for instance variables of a class
* use generic var to declare variables
	* must be initialized when declared
	* type is inferred from initial value
* to declare typeless classes, use var x = something

# L8.3 - Higher Order functions
higher order functions take another function as argument
example:
* Myclass creates a time T
* t starts running in parallel
* t notifies m when time limit expres
* m needs to pass timerdone() to t

passing functions
* interfaces that define a single function are called functional interfaces
	* Comarator, TimerOwner
* How can we directly pass the required function?
* In Python, function names are similar to variable name
	* define a function
	* pass it as an argument to another
	* map is a higher order function

lambda expressions
* denote anonymous functions
	* (parameters) -> Body
	* Return value and type are implicit
* From lambda calculus (Alonzo Church)
	* foundational model to computing parallel to Alan Turing
* Substitute wherever a functional interface is specified

Method references
* ClassName::StaticMethod
	* Method reference in c::f
	* corresponding expression with as many arguments as f has
	* `(x1, ... ,xk) -> f(x1, ... , xk)`
* ClassName::InstanceMethod
	* called with respect to an object that becomes implicit parameter
	* `(o, x1, ... , xk) -> o.f()`
* ObjectName::InstanceMethod
	* o::f

## Summary
* In OOP higher order function achieved using interfaces
	* Encapsulate function to be passed as an object
* Java allows functions passed directly in place of functional interfaces
	* Interface consists of a single function
* Lambda expressions describe anonymous functions
	* cannot pass lambda expressions in general
	* only when argument is a functional interface
* Can pass a method reference if lambda expression consists of a single function call

# L8.4 - Streams
Operating on collections
* We usually use an iterator to process a collection
	* suppose we have split a text file as a list of words
	* we want to count the number of long words in the list
* An iterator generates all elements from a collection as a sequence
* Alternative approach
	* Generate a stream of values from a collection
	* operations transform input streams into output streams
	* terminate with a result
	* eg: `long count = words.stream().filter(w->w.length()>10).count()`
* Stream processing is declarative
	* focus is on what to compute rather than how, apart from imperative programming
* Processing can be parallelized
	* filter() and count() in parallel
* Lazy evaluation is possible
	* suppose we want first 10 long words
	* step generating the stream once we find 10 such words
	* Need not generate the entire stream in advance
	* Can even work with infinite stream

Working with streams
* Create a stream
* pass through intermediate operations that transform streams
* Apply a terminal operation to get a result
* A stream does not store its elements
	* Elements stored in an underlying collection
	* or generated by a function on demand
* Stream operations are non-destructuve

Creating Streams
* apply stream() to a collection
	* part of Collections interface
* Use static method Stream.of() for arrays
* Static method Stream.generate() generates a stream from a function
	* provide a function that produces values on demand, with no argument
* Stream.iterate() - a stream of dependent values
	* initial value, function to generate the next value from previous one
	* terminate using a predicate

Processing streams
* filter() to select elements
	* takes a predicate as argument
	* Filter out the long words
* map() applies a function to each element in the stream
	* extract the first letter of each long word
* What if map function generates a list?
	* Suppose we have explode(s) that returns the list of letters in s
	* map() produces stream with nested lists
* flatMap() falttens nested list into a single stream

Stream transformations
* make a stream finite - limit(n)
	* generate 100 random numbers
* skip n elements - skip(n)
	* discard first 10 numbers
* stop when element matches a criterion - takeWhile()
* Start after element matches a criterion - dropWhile()
* Can combine streams, extract

Reducing a stream to a result
* Number of elements - count()
	* count random numbers larger than 0.1
* Largest and smallest values seen
	* max() and min()
	* requires a comparison function
	* What happens if the stream is empty, return value is optional type
* First element - findFirst()
	* first random number above threshold